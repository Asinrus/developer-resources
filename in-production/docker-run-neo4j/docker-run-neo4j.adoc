= How-To: Run Neo4j in Docker
:slug: docker-run-neo4j
:section: Neo4j in Production
:section-link: in-production
:section-level: 1

.Goals
[abstract]
You will learn how to create and run a Neo4j graph database in a Docker container.
This tutorial is designed for you to follow along and step through the process.

.Prerequisites
[abstract]
This guide builds upon the basic concepts discussed in earlier guides and some knowledge of Docker.
To better understand and utilize Neo4j with Docker, it helps to know the following:
* link:/developer/get-started/graph-database/[What is a Graph Database?]
* link:https://www.docker.com/resources/what-container[Docker: What is a Container?^]

You should also have downloaded link:https://www.docker.com/get-started[Docker^] for your appropriate operating system and be familiar with navigating it from the command line.

== Neo4j Docker Image

There is an official https://hub.docker.com/_/neo4j[Neo4j image on DockerHub^] we can use to give us a standard, ready-to-run package of Neo4j.
From the DockerHub repo, you can choose to run Community Edition or Enterprise with a variety of versions of the database.

The Neo4j Docker image includes some basic configuration defaults that should not need adjustment for most cases, including set memory and caching values.
If interested, the full list of default configurations for Neo4j in Docker can be found on https://github.com/neo4j/docker-neo4j/blob/master/src/3.5/docker-entrypoint.sh[the GitHub repository^].

By default, the Docker image also exposes three ports for remote access:
* 7474 for HTTP
* 7473 for HTTPS
* 7687 for Bolt

It is also possible to create a custom Docker image with Neo4j included, but we will not cover that here.

== Run Docker with Neo4j

Retrieving and running Neo4j within a Docker container is very simple using one of the provided images.
You simply need to execute the basic `docker run` command with the `neo4j` image and specify any options or versions you want along with that.
We will take a look at a few options available with the `docker run` command.

[%autowidth.spread]
|===
|*Option* |*Description* |*Example*
|`--name` |Name your container (avoids generic container id) |`docker run --name myneo4j neo4j`
|`-p` |Specify container ports to expose |`docker run -p7687:7687 neo4j`
|`-d` |Detach container to run in background and print container ID |`docker run -d neo4j`
|`-v` |Bind mount a volume |`docker run -v $HOME/neo4j/data:/data neo4j`
|`--help` |Output full list of options for `docker run` |`docker run --help`
|===

Let us go ahead and create our Neo4j container by running the command below.
An explanation of each option is in the following paragraphs.

[source,bash]
----
docker run \
    --name testneo4j \
    -p7474:7474 -p7687:7687 \
    -d \
    -v $HOME/neo4j/data:/data \
    -v $HOME/neo4j/logs:/logs \
    -v $HOME/neo4j/import:/var/lib/neo4j/import \
    -v $HOME/neo4j/plugins:/plugins \
    neo4j:latest
----

The `docker run` simply creates and starts a container.
On the next line, `--name testneo4j` defines the name we want to use for the container as `testneo4j`.
This avoids a generic id getting assigned as the container name, which makes referencing your container more complicated and difficult to remember.

Using the `-p` option with ports 7474 and 7687 allows us to expose and listen for traffic on both the HTTP and Bolt ports.
Having the HTTP port means we can connect to our database with Neo4j Browser, and the Bolt port means efficient and type-safe communication requests between other layers and the database.
Next, we have `-d`.
This detaches the container to run in the background, meaning we can access the container separately and see into all of its processes.

The next several lines start with the `-v` option.
These lines define volumes we want to bind in our local directory structure so we can access certain files locally.

The first one is for our `/data` directory, which stores the authentication and roles for each database, as well as the actual data contents of each database instance (in `graph.db` folder).
The second `-v` option is for the `/logs` directory.
Outputting the Neo4j logs to a place outside the container ensures we can troubleshoot any errors in Neo4j, even if the container crashes.
The third line with the `-v` option binds the import directory, so we can copy CSV or other flat files into that directory for importing into Neo4j.
Load scripts for importing that data can also be placed in this folder for us to execute.
The next `-v` option line sets up our plugins directory.
If we want to include any custom extensions or add the Neo4j APOC or graph algorithms library, exposing this directory simplifies the process of copying the jars for Neo4j to access.

Finally, the final line of the command above references the Docker image we want to pull from DockerHub (`neo4j`), as well as any specified version (in this case, just the `latest` edition).


== Verifying Execution
Once you execute this command, Neo4j should be running in our Docker container!
You can verify this by running `docker ps`.

[NOTE]
--
If you do not see your container in the list when you run `docker ps`, you can run `docker ps -a` instead to see if the container crashed and any associated exit codes.
--

== Other Functionality for Neo4j Containers
Much of the other typical Neo4j processes for importing data, adding plugins, and interacting via Neo4j Browser work the same way as with any other Neo4j installation with the proper directory volumes mounted.

== Wrapping Up
Congratulations!
You have successfully created and started a Neo4j graph database in a Docker container!

If you have any questions or need assistance using Neo4j with Docker, reach out to us on the https://community.neo4j.com/[Community Site^]!

To learn more about running Neo4j with Docker, check out our https://neo4j.com/docs/operations-manual/current/docker/[documentation^].