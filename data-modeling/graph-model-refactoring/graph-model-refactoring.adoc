= Graph Model Refactoring
:slug: graph-model-refactoring
:level: Intermediate
:section: Cypher Query Language
:section-link: cypher
:sectanchors:
:toc:
:toc-title: Contents
:toclevels: 1

.Goals
[abstract]
Building on the Cypher Basics guides, this guide provides a worked example of changing a graph model.
Upon finishing this guide, you should be able to evolve your graph model based on changing requirements.

.Prerequisites
[abstract]
You should be familiar with link:/developer/get-started/graph-database[graph database] concepts and the link:/developer/get-started/graph-database#property-graph[property graph model].
This guide is a continuation of the concepts discussed in the previous Cypher sections.
You should be familiar with link:/developer/cypher/cypher-query-language[MATCH], link:/developer/cypher/cypher-basics-ii/[Create/Update/Delete], and link:/developer/cypher/filtering-query-results/[Filtering] concepts before walking through this guide.

[role=expertise]
{level}

[#airports-dataset]
== Airports dataset

In this guide we're going to use an airports dataset.
This is the graph model that we're going to use:

image::{img}initial_model.svg[link="{img}initial_model.svg",role="popup-link"]

The following query imports the data into this model:

[source,cypher]
----
CREATE CONSTRAINT ON (airport:Airport)
ASSERT airport.code IS UNIQUE
----

[source,cypher]
----
LOAD CSV WITH HEADERS FROM "https://raw.githubusercontent.com/neo4j-contrib/training/master/modeling/data/flights_1k.csv" AS row
MERGE (origin:Airport {code: row.Origin})
MERGE (destination:Airport {code: row.Dest})
MERGE (origin)-[connection:CONNECTED_TO {
  airline: row.UniqueCarrier,
  flightNumber: row.FlightNum,
  date: date({year: toInteger(row.Year), month: toInteger(row.Month), day: toInteger(row.DayofMonth)}),
  cancelled: row.Cancelled,
  diverted: row.Diverted}]->(destination)
ON CREATE SET connection.departure = localtime(apoc.text.lpad(row.CRSDepTime, 4, "0")),
              connection.arrival = localtime(apoc.text.lpad(row.CRSArrTime, 4, "0"))
----

.Results
|===
| Added 62 labels, created 62 nodes, set 7062 properties, created 1000 relationships, completed after 376 ms.
|===


[#property-to-boolean]
== Convert property to boolean

The `diverted` and `cancelled` properties were both imported as string values of `1` and `0`.
We can use the https://neo4j.com/docs/labs/apoc/current/graph-updates/graph-refactoring/normalize-boolean/[`apoc.refactor.normalizeAsBoolean`^] procedure to convert these properties to boolean values.

image::{img}boolean_refactoring.svg[link="{img}boolean_refactoring.svg",role="popup-link"]

The following query does this for the `diverted` property:

[source,cypher]
----
MATCH (:Airport)-[connectedTo:CONNECTED_TO]->(:Airport)
CALL apoc.refactor.normalizeAsBoolean(connectedTo, "diverted", ["1"], ["0"])
RETURN count(*)
----

.Results
[opts="header"]
|===
| count(*)
| 1000
|===

And the following query does this for the `cancelled` property:


[source,cypher]
----
MATCH (origin:Airport)-[connectedTo:CONNECTED_TO]->(departure)
CALL apoc.refactor.normalizeAsBoolean(connectedTo, "cancelled", ["1"], ["0"])
RETURN count(*)
----

.Results
[opts="header"]
|===
| count(*)
| 1000
|===

If we have a lot of relationships to update, we may get an OutOfMemory exception if we try to refactor them all in one transaction.
We can therefore process them in batches using the https://neo4j.com/docs/labs/apoc/current/graph-updates/periodic-execution/#commit-batching[`apoc.periodic.iterate`^] procedure:

[source,cypher]
----
UNWIND ["cancelled", "reverted"] AS propertyToDelete
CALL apoc.periodic.iterate(
  "MATCH (:Airport)-[connectedTo:CONNECTED_TO]->(:Airport) RETURN connectedTo",
  "CALL apoc.refactor.normalizeAsBoolean(connectedTo, $propertyToDelete, ['1'], ['0'])
   RETURN count(*)",
  {params: {propertyToDelete: propertyToDelete}, batchSize: 100, iterateList: true})
YIELD batches
RETURN propertyToDelete, batches
----

.Results
[opts="header"]
|===
| propertyToDelete | batches 
| "cancelled"      | 10 
| "reverted"       | 10 
|===

Once we've done this, we can write the following query to return all cancelled connections:

[source,cypher]
----
MATCH (origin:Airport)-[connectedTo:CONNECTED_TO]->(destination)
WHERE connectedTo.cancelled
RETURN origin.code AS origin, 
       destination.code AS destination, 
       connectedTo.date AS date, 
       connectedTo.departure AS departure, 
       connectedTo.arrival AS arrival
----

.Results
[opts="header"]
|===
| origin | destination | date | departure | arrival
| "LAS"  | "OAK"       | 2008-01-03 | 07:00     | 08:30 
| "LAX"  | "SFO"       | 2008-01-03 | 09:05     | 10:25   
| "LAX"  | "OAK"       | 2008-01-03 | 11:00     | 12:15   
| "LAX"  | "SJC"       | 2008-01-03 | 19:30     | 20:35   
| "LAX"  | "SFO"       | 2008-01-03 | 16:20     | 17:40   
| "MDW"  | "STL"       | 2008-01-03 | 11:10     | 12:15   
| "MDW"  | "BDL"       | 2008-01-03 | 08:45     | 11:40   
| "MDW"  | "DTW"       | 2008-01-03 | 06:00     | 08:05   
| "MDW"  | "STL"       | 2008-01-03 | 14:45     | 15:50   
| "MDW"  | "BNA"       | 2008-01-03 | 19:25     | 20:45   
| "OAK"  | "BUR"       | 2008-01-03 | 13:10     | 14:15   
| "OAK"  | "BUR"       | 2008-01-03 | 17:05     | 18:10                                                    
|===

[#create-node-from-relationship]
== Create node from relationship

Now let's evolve our model to create a `Flight` node from the properties stored on the `CONNECTED_TO` relationship.

image::{img}flight_node.svg[link="{img}flight_node.svg",role="popup-link"]

The following query does this refactoring:

[source,cypher]
----
CALL apoc.periodic.iterate(
  "MATCH (origin:Airport)-[connected:CONNECTED_TO]->(destination:Airport) RETURN origin, connected, destination",
  "CREATE (flight:Flight { 
     date: connected.date, 
     airline: connected.airline, 
     number: connected.flightNumber,
     departure: connected.departure, 
     arrival: connected.arrival,
     cancelled: connected.cancelled,
     diverted: connected.diverted
   })
   MERGE (origin)<-[:ORIGIN]-(flight)
   MERGE (flight)-[:DESTINATION]->(destination)
   DELETE connected",
  {batchSize: 100})
----

The query executes the following steps:

* Find all `CONNECTED_TO` relationships
* Create a `Flight` node per relationship
* Create `ORIGIN` and `DESTINATION` relationships from that `Flight` to the appropriate `Airport` nodes
* Delete the `CONNECTED_TO` relationship

If we execute the query we'll see the following output:

.Results
[opts="header"]
|===
| batches | total | timeTaken | committedOperations | failedOperations | failedBatches | retries | errorMessages | batch                                           | operations                                      | wasTerminated 
| 10      | 1000  | 0         | 1000                | 0                | 0             | 0       | {}            | {total: 10, committed: 10, failed: 0, errors: {}} | {total: 1000, committed: 1000, failed: 0, errors: {}} | FALSE                                                                   
|===


We can also do this refactoring using the https://neo4j.com/docs/labs/apoc/current/graph-updates/graph-refactoring/extract-node-from-relationship/[`apoc.refactor.extractNode`^] procedure.

[source,cypher]
----
CALL apoc.periodic.iterate(
  "MATCH (origin:Airport)-[connected:CONNECTED_TO]->(destination:Airport) 
   RETURN origin, connected, destination",
  "CALL apoc.refactor.extractNode([connected], ['Flight'], 'DESTINATION', 'ORIGIN')
   YIELD input, output, error
   RETURN input, output, error",
  {batchSize: 100});
----

.Results
[opts="header"]
|===
| batches | total | timeTaken | committedOperations | failedOperations | failedBatches | retries | errorMessages | batch                                           | operations                                      | wasTerminated 
| 10      | 1000  | 0         | 1000                | 0                | 0             | 0       | {}            | {total: 10, committed: 10, failed: 0, errors: {}} | {total: 1000, committed: 1000, failed: 0, errors: {}} | FALSE                                                                
|===


[#create-node-from-property]
== Create node from property

At the moment the airline for our flights is stored as a property on the `Flight` nodes.
Now we're going to create a node for each airline with an `Airline` label.

image::{img}airline.svg[link="{img}airline.svg",role="popup-link"]

Let's first create a constraint on the `Airline` label and `name` property so that we don't create duplicate nodes: 

[source,cypher]
----
CREATE CONSTRAINT ON (airline:Airline)
ASSERT airline.name IS UNIQUE
----

.Results
|===
| 0 rows available after 107 ms, consumed after another 0 ms. Added 1 constraints
|===

And now we can execute the following query to do the refactoring:

[source,cypher]
----
CALL apoc.periodic.iterate(
   'MATCH (flight:Flight) RETURN flight',
   'MERGE (airline:Airline {name:flight.airline}) 
    MERGE (flight)-[:AIRLINE]->(airline)
    REMOVE flight.airline',
   {batchSize:10000, iterateList:true, parallel:false}
)
----

.Results
[opts="header"]
|===
| batches | total | timeTaken | committedOperations | failedOperations | failedBatches | retries | errorMessages | batch                                           | operations                                      | wasTerminated 
| 1       | 1000  | 0         | 1000                | 0                | 0             | 0       | {}            | {total: 1, committed: 1, failed: 0, errors: {}} | {total: 1000, committed: 1000, failed: 0, errors: {}} | FALSE                                                                
|===


[#cypher-resources]
=== Resources

This guide has shown how to refactor a graph model, with help from procedures in the APOC Library.
Below are some resources for learning more about refactoring in Neo4j:

* link:https://neo4j.com/developer/neo4j-apoc/[APOC Library^]
** https://neo4j.com/docs/labs/apoc/current/graph-updates/graph-refactoring/[Graph Refactoring Procedures^]
